学习笔记

HashMap的put/get方法的总结：
有道云笔记链接：http://note.youdao.com/noteshare?id=486cc511c3397fc147883bbebeb50fd6

其他小结：

哈希表：
底层：数组+链表（链表下挂冲突情况下）

哈希表：增删改的时间复杂度O（1）

但是哈希冲突退化成链表的时候O（n)

java中常用的是HashMap k -v（k是不重复的）

                       HashSet(元素不重复，复杂类元素需要实现HashCode方法）





常用Api:





说明：

HashSet底层使用的是HashMap.只不过他将存储的对象放在HashMap的key位置 ：



在java中的TreeSet底层是红黑树或者平衡树。时间复杂度为O(logN)


-----------------------

二叉搜索树：

特征：左孩子<根<右孩子

所以二叉搜索树的中序遍历就是升序排序了

介绍：

二叉搜索树又叫二叉查找树，又叫二叉有序树。它不同于平衡二叉树， 平衡二叉树又称AVL树，它或者是一棵空树，或者是它的左、右树都是平衡二叉树且左、右字数的高度之差的绝对值不超过1.(后续会介绍）

时间复杂度：log(N)-查询/插入

链表的查询时O(n)的，所以二叉查找树要快好多


---------------------------
堆：
介绍：

  堆可以迅速找到最大或者多小值，场景就是大顶堆和小顶堆， 堆是个接口，底下实现的很多，之前介绍的优先队列PriorityQueue就是个堆的具体体现。

其下实现有：二叉堆，斐波那契堆。其实平很二叉树也可以用来实现堆，堆的派系如下：

注意：

 二叉堆不是二叉搜索树，当然二叉搜索树也能做堆。但是二者还是有区别的。

     同：都是有序

     不同：二叉搜索树的操作的时间复杂度都是O（logN)级别；但是在查询最小值方面：1.二叉堆的查询最小值的时间复杂度是O（1）级别就是拿堆顶即可，2.而二叉搜索树需要遍历到最左端需要O（logN)的时间复杂度。



底层：

底层维护的是个有序的链表，为什么不用数组实现---如果使用数组的话那么insert需要排序的时间复杂度为O（nlogN)--快排。如果插入/删除在不好的位置还需要移动，这样时间复杂度最快到O（N),



二叉堆：
由于它是完全二叉树我们也可以用一维数组完成二叉堆。这和之前用数组矛盾吗？不矛盾因为这里上升维度了。调整顺序的时候是通过一维数组的下标完成的哦！

floor是取整的意思。



 

时间复杂度理解图：





最坏情况下就是树的深度：logN级别。其他操作类似


